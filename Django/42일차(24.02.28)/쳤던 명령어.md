# 이번주 목표
1. 버전 관리
2. 클래스 기반 뷰
3. admin 필드 순서 바꾸기
4. 템플릿 태그와 템플릿 필터
5. DB 설계
6. admin
7. DRF
8. comment를 클래스 기반 뷰로 작성
    - FBV
    - CBV
    - 댓글 기능은 직접 구현 안하시고 솔루션 붙이셔도 좋습니다. (대표님은 댓글 기능 disqus 많이 사용)
9. form 태그를 사용안하고는 Post 방식으로 전송할 수가 없다. -> form 태그를 사용하여 GET, POST 메서드를 설정할 수 있고 그 외는 전부 Get방식


- models.py: DB 내용을 작성하는 것 -> 내가 작성한 내용에 따라 DB가 반영되고 생성된다: 필드랑 제약조건등 작성하면 장고가 알아서 DB를 만들어줌
- models.py에서 DB 내용을 만드는 것이기 때문에 최초 작성할때 최대한 많은 내용을 구성하고 작성해야한다. 
- 안그러면 models.py를 수정할때 마다 DB내용이 변경되었으므로 실제 DB에 반영해줘야하니깐 python manage.py makemigrations, python manage.py migrate를 반복해줘야한다. (models.py는 DB를 작성하는 것이고 수정될 때마다 실제 DB에 변경 내용을 반영해줘야한다.)

- GPT : django로 서비스를 만들고 있어. Django 모델 겔러리라는 서비스야. 이 서비스는 사람들이 들어와서 자신만에 django 모델과 ERD를 올려서 사람들과 공유할 수 있는 서비스야. 이 서비스에 ERD를 머메이드로 그려줘. 텍스트로 설명할 필요 없이 이 서비스에 ERD를 머메이드 코드로 나에게 줘.
* 머메이드 코드
erDiagram
    USER ||--o{ DJANGOMODEL : "owns"
    DJANGOMODEL ||--|{ ERDIMAGE : "contains"

    USER {
        int id PK "Primary Key"
        string username "Unique"
        string email "Unique"
        string password
    }

    DJANGOMODEL {
        int id PK "Primary Key"
        int userId FK "Foreign Key to USER"
        string modelName "Model name"
        string description "Model description"
        dateTime created_at "Creation date"
    }

    ERDIMAGE {
        int id PK "Primary Key"
        int modelId FK "Foreign Key to DJANGOMODEL"
        string imageUrl "URL to image"
        string description "Image description"
    }





# 명령어
```python

# 이제 venv를 밖에 빼서 모든 솔루션에 동일하게 적용되도록 하겠다. => 하나의 가상환경을 전체 솔루션이 사용하는 것
# 가상환경 잡는 것은 이제 생략하겠다.
# 공통의 가상환경을 사용하기 위해 상위 경로에 가상환경을 설치


mkdir mysite
cd mysite

# python -m venv venv -> 상위 경로에서 공통으로 관리

..\..\venv\Scripts\activate
pip install django

pip freeze > requirements.txt
# pip install -r requirements.txt # 추후 이 파일을 통해 설치합니다.
# 왜 이 파일이 필요한가요? GitHub에 가상환경을 제외하고 올리니깐! -> 계속 매번 설치하기 힘드니 한곳에 설치 내역을 모아놓고 추후 해당 파일로 설치

django-admin startproject tutorialdjango .
python manage.py migrate

# settings.py에서 접속할 수 있는 사람 설정
ALLOWED_HOSTS = ['*'] # 28번째 줄에 접속할 수 있는 사람을 모든 사람으로 변경

python manage.py startapp blog

# settings.py 에서 33번째 라인 수정
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'blog',
]

###################################
# blog > models.py

from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    head_image = models.ImageField(
        upload_to='blog/images/%Y/%m/%d/', blank=True)
    file_upload = models.FileField(
        upload_to='blog/files/%Y/%m/%d/', blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateField(auto_now=True)

    def __str__(self):
        return self.title

###################################

python manage.py makemigrations
python manage.py migrate

###################################

python manage.py createsuperuser

leehojun
leehojun@gmail.com
이호준123!@

###################################

이미지가 실제 저장될 폴더 설정입니다.
settings.py에 맨 마지막 줄에 추가해주세요.

# 언어, 시간 변경
LANGUAGE_CODE = 'ko-kr'
TIME_ZONE = 'Asia/Seoul'

STATIC_URL = "static/"
STATICFILES_DIRS = [BASE_DIR / "static"]

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"

###################################

mysite > media 폴더 생성
mysite > static 폴더 생성

###################################

# tutorialdjango > urls.py
from django.contrib import admin
from django.urls import path, include
from django.conf.urls.static import static
from django.conf import settings

urlpatterns = [
    path('admin/', admin.site.urls),
    path('blog/', include('blog.urls')),
]

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

###################################
# blog > urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('', views.blog_list, name='blog_list'),
]

###################################
# blog > views.py

from django.shortcuts import render
from .models import Post

def blog_list(request):
    posts = Post.objects.all()
    context = {'posts':posts}
    return render(request, 'blog/blog_list.html', context)

###################################
# blog > templates > blog > blog_list.html
# tip: new file 누르시고 templates/blog/blog_list.html
# 명령어 mkdir blog/templates/blog/blog_list.html

비어있는 파일로 만들어주세요!

###################################
# blog > admin.py

from django.contrib import admin
from .models import Post

admin.site.register(Post)

###################################

python manage.py runserver

admin page 들어가셔서 게시물 6개 생성
# 5개 게시글 순서대로 작성해주세요.
# title명과 contents 내용입니다.

1 11
2 <h1>hello world</h1>
3 <script>alert('hello')</script>
4 # hello world
5 Lorem ipsum dolor sit amet consectetur adipisicing elit. Ducimus reprehenderit ad pariatur tenetur explicabo impedit culpa dicta error! Sint aliquam unde voluptate pariatur. Perferendis nihil, veniam commodi sequi architecto nam?
6 hello
world
안녕하세요.

###################################
# error 해결! -> 애러 발생에 대한 해답(models.py에 반영x)
# 아래와 같이 하면 post에는 항목이 하나 더 추가되어 나옵니다. 그러나 실제로 저장버튼을 누르면 no such table:blog_list라고 나와요. 자주보시는 애러이니 눈에 익히시고 가시면 좋습니다. 수정한다음 다시 원상태로 돌려주세요.

from django.db import models


class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    content2 = models.TextField()

    def __str__(self):
        return self.title


###################################
# 템플릿 변수 {{ 변수 }}
# 템플릿 필터 {{ 변수|필요작업 }}
blog > templates > blog > postlist.html

# 이걸 사용하면 <h1> 과 같은 태그가 적용이 안된다.
{% for i in posts %}
    <p>{{i.id}}</p>
    <p>{{i.title}}</p>
    <p>대문자: {{i.content|upper}}</p>
    <p>소문자: {{i.content|lower}}</p>
    <p>줄바꿈 안함: {{i.content}}</p>
    <p>줄바꿈: {{i.content|linebreaks}}</p>
    <hr>
{% endfor %}

{% lorem 2 p %}

###################################

# html 태그가 적용된다.

{% for i in posts %}
    <p>{{i.id}}</p>
    <p>{{i.title}}</p>
    <p>대문자: {{i.content|upper}}</p>
    <p>소문자: {{i.content|lower}}</p>
    <p>줄바꿈 안함: {{i.content}}</p>
    <p>줄바꿈: {{i.content|linebreaks}}</p>
    <p>말줄임: {{i.content|truncatewords:5}}</p>
    <p>말줄임: {{i.content|truncatewords:7}}</p>
    <p>슬라이싱: {{i.content|slice:":10"}}</p>
    <p>공백 병합(join): {{i.content|join:'-'}}</p>
    <p>['hello', 'world', 'hi'] => hello-world-hi</p>
    <p>길이: {{i.content|length}}</p>
    {% if i.content|length >= 20 %}
        <p>길이가 20자 이상입니다.</p>
    {% endif %}
    <p>태그 없애기: {{i.content|striptags}}</p>
    <p>문자열에 더하기: {{i.content|add:"!"}}</p>
    <p>변수로 추가하기: {{i.content|add:i.title}}</p>
    <p>날짜: {{i.created_at}}</p>
    <p>날짜 형식 바꾸기: {{i.created_at|date:"y/m/d"}}</p>
    <p>날짜 형식 바꾸기: {{i.created_at|date:"y-m-d"}}</p>
    <p>날짜 형식 바꾸기: {{i.created_at|date:"y"}}</p>
    <p>날짜 형식 바꾸기: {{i.created_at|date:"Y"}}</p>
    <p>날짜 형식 바꾸기: {{i.created_at|date:"M"}}</p>
    <p>날짜 형식 바꾸기: {{i.created_at|date:"D"}}</p>
    <p>날짜 형식 바꾸기: {{i.created_at|date:"h"}}</p>
    <p>날짜 형식 바꾸기: {{i.created_at|date:"i"}}</p>
    <p>필터 중첩: {{i.content|upper|linebreaks|truncatewords:10}}</p>
    <hr>
{% endfor %}

<!-- 저는 잘 사용하진 않습니다. -->
{% lorem 1 b random %}
{% lorem 1 p random %}
{% lorem 2 w random %}
<!-- 단어 w, 단락 p, 일반텍스트 b -->
{# lorem [count] [method] [random] #}
###################################

{% for i in posts %}
    <h1>{{ i.title }}</h1>
    <p>{{ i.content }}</p>
    <p>{{ forloop.counter }}</p>
    <p>{{ forloop.counter0 }}</p>
    <p>{{ forloop.counter|add:100 }}</p>
    <p>{{ forloop.revcounter }}</p>
    <p>{{ forloop.first }}</p>
    <p>{{ forloop.last }}</p>
    <hr>
{% endfor %}

###################################

{# 자주 사용하지 않습니다. #}
{% with value='hello world' %}
    <h1>{{value}}</h1>
{% endwith %}

###################################

{# 주석입니다. #}
{% comment 'licat' %}
이 코드는 영국에서 시작되어...
{% endcomment %}
hello world

###################################

{# 실습 안합니다. #}
{% url 'some-url-name' v1 v2 %}
{% url 'some-url-name' arg1=v1 arg2=v2 %}

path("client/<int:id>/", app_views.client, name="app-views-client")
{% url 'app-views-client' client.id %}

###################################

# django의 이스케이프 기능 비활성화하는 법 2가지(특수한 경우에만 사용합니다. 이 코드는 위험합니다.)
{% for i in posts %}
    <p>{{i.content|safe}}</p>
{% endfor %}

{% for i in posts %}
    {% autoescape off %}
    <p>{{i.content}}</p>
    {% endautoescape %}
{% endfor %}

###################################
# markdown, 많이 사용합니다.
# django-markdown은 만든 사람이 많습니다.
# 제가 사용한 모듈이 비교를 해봤을 때 가장 단순하게 사용할 수 있습니다.

# 설치 -> 마크다운 사용
# pip install django-markdown-deux
# settings.py 'markdown_deux' 등록
# > settings.py의 installed_apps =[]에 'markdown_deux' 추가

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # 서드파티
    'markdown_deux',
    # 커스텀
    'blog',
]

###################################
{% load markdown_deux_tags %}
{% for i in posts %}
    <p>{{ i.content | markdown }}</p>
{% endfor %}

# 8번 게시물로 작성합니다.
# hello world
## hello world
### hello world

1. hello world
2. hello world

* hello world
* hello world
* hello world

{{'# hello world'|markdown }} # 마크다운 반영(#에 대한 마크다운 작성 시 마크다운 기능을 반영해준다.)

###################################
# blog > views.py

# 아래 코드를 교체하면 됩니다!
posts = Post.objects.all()

# 위의 코드를 1~4번까지 바꿔가면서 실습
1. 연도와 일치되는 게시물 가져오기
posts = Post.objects.filter(created_at__year=2023)

2. 월과 일치되는 게시물 가져오기
posts = Post.objects.filter(created_at__month=10)

3. 일과 일치되는 게시물 가져오기
posts = Post.objects.filter(created_at__day=17)

4. 연, 월, 일에 매칭이 되는 게시물 가져오기
gt (greater than) : >
lt (less than) : <
gte (greater than or equal) : >=
lte (less than or equal) : <=

from datetime import date

posts = Post.objects.filter(created_at__gte=date(2023,10,17))

###################################
# request 상세히 살펴보기
from django.shortcuts import render
from .models import Post
from datetime import date

def postlist(request):
    posts = Post.objects.all()
    # http://127.0.0.1:8000/blog/?q=hello
    # 공식문서 : https://docs.djangoproject.com/en/4.2/ref/request-response/
    print(request)
    print(dir(request))
    print(type(request))
    # 여기에서 출력되는 것들은 templates에서도 출력 가능합니다.
    # {{request.user}}
    print(request.user)
    print(type(request.user))
    print(dir(request.user))
    print(request.user.is_authenticated)
    print(request.user.id) # user id는 1번
    print(request.user.username)
    print(request.user.is_superuser)
    print(request.user.password)
    print(request.GET)
    print(request.GET.get('q'))
    print(request.GET.get('q'))
    print(dir(request.GET))
    print(request.GET.get('hello', 'world')) # hello라는 쿼리가 없으면 world를 출력
    print(request.POST)
    print(request.FILES)
    print(request.COOKIES) # Application > Cookies에 저장되어 있는 정보
    print(request.path)
    print(request.method)
    print(request.get_full_path_info())
    print(request.get_host())
    return render(request, 'blog/postlist.html', {'posts':posts})

###################################
모델 실습 링크 : https://www.notion.so/paullabworkspace/Model-RDB-ERD-1-N-N-M-1-1-f34426c3b50c49c1adcda1a652dfa2c1
# 1:N

# blog > models.py 수정

# db cascade 제약조건 추가!
# cascade : 부모의 정보가 수정/삭제되면 자식의 정보도 같이 수정/삭제 된다.

# 장고에서는 1 : N의 관계를 정의하기 위해 ForeignKey를 사용합니다. 또한 ForeignKey 필드는 1에 정의하는 것이 아니라  N에 정의합니다.
# ★ '1:N'인 경우 ForeignKey는 N쪽에 작성한다.

from django.db import models
from django.contrib.auth.models import User


class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    head_image = models.ImageField(
        upload_to='blog/images/%Y/%m/%d/', blank=True)
    file_upload = models.FileField(
        upload_to='blog/files/%Y/%m/%d/', blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateField(auto_now=True)
    author = models.ForeignKey(
        User, on_delete=models.CASCADE
    )

    def __str__(self):
        return self.title

###################################

# 위에 cascade 제약조건을 추가했으니 DB가 수정된 것! 따라서 DB 변경 내용을 다시 장고에 다시 반영해줘야한다. -> makemigrations, migrate 다시 수행

python manage.py makemigrations
# => fix해라!?
# => 1. 지금 넣어라
# => 2. 종료시키고 null=True를 주어라!
# 1번 입력하고 >>> 1 입력!
# 1번 유저가 author로 들어가게 됨.
# 1:N에서 1에 대응하는 id 값
python manage.py migrate

###################################

/admin으로 접속 후 다른 유저 만들고 게시물 할당해서 user 삭제해보기 - 게시글에 유저를 할당하기(유저와 게시글 연결)

cascade이기 때문에 게시글 삭제 시 유저도 같이 삭제된다.(외래키로 서로 연결되어 있고 cascade 제약조건 때문에 삭제 시 같이 삭제된다.)

###################################
on_delete=models.SET_NULL을 넣으면 빈칸으로 만들어집니다.
(외래키로 연결되어 있고 set_null 제약조건으로 인해 부모가 삭제되면 자식은 null 값으로 설정된다.)

###################################
# templates > blog > blog_list.html
{% for i in posts %}
    <h1>{{ i.title }}</h1>
    <p>{{ i.content }}</p>
    <p>{{ i.author }}</p>
    <hr>
{% endfor %}

###################################
# blog > views.py
# 간소화 작업
from django.shortcuts import render
from .models import Post

def postlist(request):
    posts = Post.objects.all()
    return render(request, 'blog/blog_list.html', {'posts':posts})


###################################

# models.py에서 DB를 정의하는 것!
# 여기서 DB 필드나 DB 내용을 정의하면 django가 알아서 DB를 셋팅

# 1:N, N:M 추가!
# models.py
from django.db import models
from django.contrib.auth.models import User


class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    head_image = models.ImageField(upload_to="blog/images/%Y/%m/%d/", blank=True)
    file_upload = models.FileField(upload_to="blog/files/%Y/%m/%d/", blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateField(auto_now=True)
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    # N:M 관계를 만들어줍니다. 어디서든 정의해도 상관 없습니다.
    tags = models.ManyToManyField("Tag", blank=True)

    def __str__(self):
        return self.title


class Comment(models.Model):
    # related_name은 Post에서 Comment를 부를 때 사용할 이름
    # 만약 이름을 licat이라 바꾸면 템플릿 문법에서 아래와 같이 호출됩니다.
    # {% for comment in post.licat.all %}
    # ForeignKey는 1:N 관계를 만들어줍니다. 단, N에서 정의합니다.
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name="comments")
    message = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateField(auto_now=True)
    author = models.ForeignKey(User, on_delete=models.CASCADE)

    def __str__(self):
        return self.message


class Tag(models.Model):
    name = models.CharField(max_length=50, unique=True)

    def __str__(self):
        return self.name

# author와 post가 comment의 외래키

###################################

# db를 호출하는 models.py를 수정했으니 다시 DB에 반영한다.
# 이렇게 계속 수정한 내용을 반영해야하는 번거로움이 있으니 처음 models.py에서 DB 내용을 작성할 때 최대한 많은 필드를 작성하고 최대한 많은 정보를 작성하고 DB에 반영하는 것이 좋다.

python manage.py makemigrations
python manage.py migrate

###################################
# admin.py
# DB 내용을 admin에 반영
# admin 페이지는 내가 DB에 저장한 데이터들을 관리하기 위한 공간

from django.contrib import admin
from .models import Post, Comment, Tag

admin.site.register(Post) # Post DB 내용과
admin.site.register(Comment) # Comment DB 내용과
admin.site.register(Tag) # Tag DB 내용을 admin 페이지에 반영
# 여기서의 Tag가 인스타그램에서 사용하는 해쉬태그 (# 태그)와 동일한 원리

###################################

python manage.py runserver한 다음

뎃글 생성
태그 생성
연결
지우기

등을 실습

###################################
# blog > urls.py

# detail 추가

from django.urls import path
from . import views

urlpatterns = [
    path('', views.blog_list, name='blog_list'),
    path('<int:pk>/', views.blog_detail, name='blog_detail'),
]

###################################
# blog > views.py

# detail 추가

from django.shortcuts import render
from .models import Post

# def blog_list(request):
#     posts = Post.objects.all()
#     return render(request, 'blog/blog_list.html', {'posts':posts})

# 추가
def blog_detail(request, pk):
    post = Post.objects.get(pk=pk)
    return render(request, 'blog/blog_detail.html', {'post':post})

###################################
# blog_detail.html

<h1>{{ post.title }}</h1>
<p>{{ post.content }}</p>
<p>{{ post.author }}</p>

###################################
# blog_list.html

# 기존 내용 수정

{% for post in posts %} # 여기서 posts는 Post.objects.all()의 객체
    <h1>{{ post.title }}</h1> # 여기서 post는 Post.objects.get()의 객체
    <p>{{ post.content }}</p>
    <p>{{ posti.author }}</p>
    <!-- 필드에 없어도 1:N으로 연결되었으면 1쪽에서 접근 가능합니다. -->
    <!-- 그렇지만 아래처럼 접근하면 None입니다! 이유는 comments 전체를 로딩할 수가 없습니다. -->
    <p>{{ post.comments }}</p> 
    <p>{{ post.tags }}</p>
    {% for comment in post.comments.all %}
        <p>{{ comment.message }}</p>
    {% endfor %}
    {% for tag in post.tags.all %}
        <p>{{ tag.name }}</p>
    {% endfor %}
    <hr>
{% endfor %}

###################################
# blog_detail.html
# 코드 추가

<h1>{{ post.title }}</h1>
<p>{{ post.content }}</p>
<p>{{ post.author }}</p>

<p>태그</p>
{% for comment in post.comments.all %} # post의 comments를 전부 가져옴(게시글의 댓글을 전부 가져옴)
    <p>{{ comment.message }}</p>
{% endfor %}

<p>댓글</p>
{% for tag in post.tags.all %} # post의 tags를 전부 가져옴(게시글과 연결된 tag 전부 가져옴)
    <p>{{ tag.name }}</p>
{% endfor %}

###################################
# blog_detail.html
# 코드 추가

<h1>{{ post.title }}</h1>
<p>{{ post.content }}</p>
<p>{{ post.author }}</p>

{% for comment in post.comments.all %}
    <p>{{ comment.message }}</p>
{% endfor %}
{% for tag in post.tags.all %}
    <p>#{{ tag.name }}</p>
{% endfor %}

###################################
# blog_detail.html

<h1>{{ post.title }}</h1>
<p>{{ post.content }}</p>
<p>{{ post.author }}</p>

{% for comment in post.comments.all %}
    <p>{{ comment.message }}</p>
{% endfor %}
{% for tag in post.tags.all %}
    <a href="/blog/tag/{{ tag.name }}">#{{ tag.name }}</a>
{% endfor %}

###################################

# blog > urls.py
# 코드 추가

from django.urls import path
from . import views

urlpatterns = [
    path("", views.blog_list, name="blog_list"),
    path("<int:pk>/", views.blog_detail, name="blog_detail"),
    path("tag/<str:tag>/", views.blog_tag, name="blog_tag"),
]

###################################
# blog > forms.py

from django import forms

class CommentForm(forms.Form):
    message = forms.CharField(widget=forms.Textarea)

###################################
# blog_detail.html

<h1>{{ post.title }}</h1>
<p>{{ post.content }}</p>
<p>{{ post.author }}</p>

{% for comment in post.comments.all %}
    <p>{{ comment.message }}</p>
{% endfor %}
{% for tag in post.tags.all %}
    <a href="/blog/tag/{{ tag.name }}">#{{ tag.name }}</a>
{% endfor %}

<form action="" method="post">
    {% csrf_token %}
    {{ form }}
    <input type="submit">
</form>


###################################
# blog > views.py 
# 코드 수정 -> blog_detail 함수 수정, tag 함수 추가

from django.shortcuts import render
from .models import Post, Comment, Tag
from .forms import CommentForm


def blog_list(request):
    posts = Post.objects.all()
    return render(request, "blog/blog_list.html", {"posts": posts})


def blog_detail(request, pk):
    post = Post.objects.get(pk=pk)
    form = CommentForm()
    if request.method == "POST":
        form = CommentForm(request.POST)
        if form.is_valid():
            author = request.user
            message = form.cleaned_data["message"]
            c = Comment.objects.create(author=author, message=message, post=post)
            c.save()
    return render(request, "blog/blog_detail.html", {"post": post, "form": form})


def blog_tag(request, tag):
    posts = Post.objects.filter(tags__name__iexact=tag)
    return render(request, "blog/blog_list.html", {"posts": posts})
```